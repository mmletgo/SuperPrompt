### **第四阶段：UI设计 (UI Design)**

#### **指令: UI设计实施**

* **目标:** 你作为`ui-designer`，基于线框图和用户流程，高效、高质量地创建完整的UI设计系统-设计规范文档和所有界面的高保真视觉稿。
* **UI风格:** 极简主义、扁平化设计
* **任务分析:** `ui-designer` 首先分析需求文档，制定工作计划：
  1. 读取 `designs/ux/wireframes/`文件夹下的线框图md文件、`designs/ux/user-flows.md`、`docs/front-end-spec.md` 文件，全面理解需求和约束条件
  2. 识别所有需要设计的页面、组件和交互状态
  3. 按优先级规划工作：设计系统基础 → 核心UI组件 → 页面布局和界面设计

* **设计工作内容:**
  
  **1. 设计系统基础创建**
  * **调色板设计:** 定义主色调、辅助色、中性色和状态色（成功、警告、错误、信息），每种颜色提供完整的色阶变化和十六进制代码
  * **字体系统:** 确定主标题、副标题、正文、辅助文本等各级文本的字体族、字号、行高、字重和颜色规范
  * **间距系统:** 定义统一的间距规范（4px、8px、16px、24px、32px等），用于组件内外边距和布局网格
  * **圆角和阴影:** 统一定义组件圆角规范和阴影层次系统

  **2. 基础组件设计**
  * 按钮（主按钮、次要按钮、文本按钮等各种样式及其状态）
  * 表单控件（输入框、下拉选择、复选框、单选框、开关等）
  * 导航组件（顶部导航、侧边栏、面包屑、分页等）
  * 反馈组件（提示框、模态框、Toast通知、加载状态等）
  * 数据展示组件（表格、卡片、列表、标签等）

  **3. 核心业务组件设计**
  * 根据 `docs/front-end-spec.md`和`designs/ux/wireframes/`中标识的业务组件(文档中用线框图绘制的组件)，设计专用的界面元素
  * 为每个组件定义多种状态：默认、悬停、激活、禁用、加载、错误等
  * 明确组件的内外边距、尺寸规范和响应式行为

  **4. 页面视觉稿设计**
  * 基于线框图和用户流程，为每个页面创建高保真视觉设计
  * 确保页面设计符合设计系统规范，保持视觉一致性
  * 考虑不同屏幕尺寸的响应式布局
  * 为关键交互路径设计过渡状态和微交互效果
  * 设计完成后，要使用chrome-devtools mcp测试是否与线框图对应一致

* **技术实现要求:**
  * 使用 Tailwind CSS 和 shadcn/ui 的设计理念和组件库风格
  * 所有HTML文件必须是独立可运行的，包含完整的样式定义
  * 确保设计的可访问性（对比度、键盘导航、屏幕阅读器友好）
  * **在执行设计时，如果发现系统中已存在相关的设计文件，必须优先基于现有文件进行修改和完善，而不是从头开始重写**

* **输出规范:**
  * **设计规范文档: 创建 `designs/ui/design-spec.md`，包含完整的设计系统文档**
  * **组件展示页面:** 
    - `designs/ui/base-components.html` - 基础组件规范展示
    - `designs/ui/core-components.html` - 核心业务组件规范展示
  * **页面视觉稿:** 为每个页面创建独立的**HTML文件**，保存到 `designs/ui/` 目录
  * **设计资源:** 如需要，提供配色方案、图标库、图片素材等设计资源

* **完成标准:**
  * 设计规范文档完整详细，包含所有设计决策的说明和使用指南
  * 所有基础组件和核心组件都有完整的视觉设计和状态定义
  * 每个页面都有对应的高保真视觉稿HTML文件
  * 所有设计文件符合技术实现要求，可直接用于前端开发
  * 整体设计保持视觉一致性和品牌统一性

* **质量验证:** `ui-designer` 完成所有设计工作后，需要进行自我检查：
  1. 确认所有输出文件都已正确保存到指定目录
  2. 验证设计规范的完整性和可操作性
  3. 检查页面视觉稿是否覆盖所有线框图中的页面
  4. 确保组件设计符合无障碍访问标准
  5. 验证整体设计的一致性和专业性

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
## 用户操作
- 检查UI是否符合你的预期，否则让ui-designer继续修改直至符合你的预期再进行下一步
- 指令3和指令4实现了微交互优化，这一步是可选的
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#### **指令 2: 生成微交互增强任务清单**

* **目标:** 基于已完成的UI设计稿，为微交互和动画效果注入创建详细的、按依赖关系和优先级排序的任务清单，专注于`whimsy-injector`的工作范围。
* **智能体:** `sprint-prioritizer`
* **任务:**
  1. **分析与生成微交互任务清单:** 调用 `sprint-prioritizer`，**输入宏观目标："基于已完成的UI设计稿，为界面注入微交互和动画效果"。** `sprint-prioritizer` 必须读取 `designs/ui/` 目录中的所有UI设计稿、`designs/ux/user-flows.md`、`docs/front-end-spec.md`、`docs/task_format_spec.md`，全面理解需求，并生成一个结构化的、按依赖关系和优先级排序的微交互增强任务列表。任务清单需按以下任务类别顺序组织：1. 基础组件微交互（按钮、表单、导航等）；2. 页面级交互动画（页面切换、状态变更）；3. 高级交互效果（AI自动更新、数据可视化动画）。
  2. **更新主JSON文件:** `sprint-prioritizer` 将生成的微交互任务列表追加到 `Worknotes/stage-4-ui-whimsy.json` 文件的 `tasks` 数组中。**生成的每个任务都必须严格按照 `docs/task_format_spec.md` 文件中定义的JSON结构进行创建，包含 `id`, `name`, `description`, `agent`（设置为"whimsy-injector"）, `status`, `dependencies`字段。微交互任务的依赖关系应该包含对应的UI设计任务ID。此清单必须按依赖关系排序，每个子任务的 `status`字段初始值必须为 `pending`。**
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#### **指令 3: 执行微交互增强任务**

* **目标:** 基于已完成的UI设计稿，高效、高质量地为所有界面注入微交互和动画效果，提升用户体验。
* **智能体:** `whimsy-injector`
* **任务说明:** 采用动态工作流调度。你根据待处理任务的数量，在"单任务模式"和"多任务并行模式"之间自动切换。

* **工作流调度:**
  1. 你持续监控 `Worknotes/stage-4-ui-whimsy.json`，筛选出所有状态为"pending"且agent为"whimsy-injector"且（无依赖任务或所有依赖任务均已"completed"）的任务，注意，你要关注这个文件里每个任务**依赖任务**这个字段，这是每个任务所依赖的任务id，你需要根据这个严格确定依赖关系。
  2. **如果符合条件的任务数量恰好为 1:** 启动 **"单任务模式"**。
  3. **如果符合条件的任务数量大于 1:** 启动 **"多任务并行模式"**。

* **模式一: 单任务模式 (Single-Task Mode)**
  * **调度:** 你针对该任务调用 `whimsy-injector`，并将 `Worknotes/stage-4-ui-whimsy.json` 中的任务状态更新为"in_progress"。
  * **执行:** `whimsy-injector` 立即开始微交互增强工作，读取对应的UI设计稿和依赖任务的产出，为其注入微交互和动画效果，特别是针对状态变更、层级导航动画和AI自动更新等场景。**在执行任务时，如果发现系统中已存在与本次设计任务相关的文件，必须优先基于现有文件进行修改和完善，而不是从头开始重写。**
  * **状态更新:** 增强完成后，`whimsy-injector` 将 `Worknotes/stage-4-ui-whimsy.json` 中对应任务的状态更新为"completed"。
  * **循环结束:** 任务完成后，流程返回 **"工作流调度"** 步骤。

* **模式二: 多任务并行模式 (Multi-Task Parallel Mode)**
  * **调度:** 你为所有符合条件的任务（无依赖任务或所有依赖任务均已"completed"）并行调用 `whimsy-injector`，并将 `Worknotes/stage-4-ui-whimsy.json` 中的任务状态更新为"in_progress"。
  * **执行:** 每个 `whimsy-injector` 读取对应的UI设计稿和依赖任务的产出，为其注入微交互和动画效果。**在执行任务时，如果发现系统中已存在与本次设计任务相关的文件，必须优先基于现有文件进行修改和完善，而不是从头开始重写。**
  * **状态更新:** 增强完成后，`whimsy-injector` 将 `Worknotes/stage-4-ui-whimsy.json` 中对应任务的状态更新为"completed"。
  * **循环:** 流程将自动返回 **"工作流调度"** 步骤。

* **完成标准:**
  * `Worknotes/stage-4-ui-whimsy.json` 中所有agent为"whimsy-injector"的任务状态均为 **"completed"**。
  * 所有包含微交互定义的最终设计稿已更新到 `designs/ui/` 目录。
  * 所有 UI 效果、布局、微动画均符合设计要求和用户体验标准。

* **输入/输出规范:**
  * **输入:** `whimsy-injector` 首先读取 `Worknotes/stage-4-ui-whimsy.json` 来获取分配给它的任务。然后读取 `designs/ui/` 中的相关UI设计稿文件，以及依赖任务的产出文件作为输入。
  * **输出:** `whimsy-injector` 将包含微交互定义的最终设计稿更新到 `designs/ui/` 目录。`Worknotes/stage-4-ui-whimsy.json` 的任务状态被实时、准确地更新。

* **完成度验证机制:** 为确保任务无遗漏，当所有微交互增强任务完成后，你必须重新调用 `sprint-prioritizer`。`sprint-prioritizer` 的任务是最终审核 `Worknotes/stage-4-ui-whimsy.json` 中agent为"whimsy-injector"的任务清单，确保所有任务都已被确认为"completed"。若发现未完成项，则必须将任务打回，并重新启动相应的微交互增强流程，直至所有任务被确认为100%完成。

* **交接文档更新:** 在所有任务都标记为"completed"后，你指派一个 `whimsy-injector` 读取 `Worknotes/stage-4-ui-whimsy.json`，在 `summary` 和 `next_stage_suggestions` 字段中记录工作摘要、产出文件位置和对下一阶段的建议，然后将更新后的 JSON 对象写回文件。

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
## 用户操作
- 检查交互动画是否符合你的预期，否则让whimsy-injector继续修改直至符合你的预期再进行下一步
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
